// `schema` is a module auto-generated by Diesel from the schema defined by the migrations in
// "migrations/" for the purpose of constructing and validating SQL queries at compile-time.
//
// See http://diesel.rs/guides/schema-in-depth/.
pub mod schema;

pub mod postgres {
    use super::schema::exercises;
    use crate::database::models::{Exercise, NewExercise, Uuid};
    use diesel::connection::Connection;
    pub use diesel::pg::PgConnection;
    use diesel::prelude::*;
    use dotenv::dotenv;
    use std::env;

    pub fn establish_connection() -> PgConnection {
        dotenv().ok();
        let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
        PgConnection::establish(&database_url)
            .expect(&format!("Error connecting to PostgreSQL {}.", database_url))
    }

    pub fn create_exercise<'a>(
        conn: &PgConnection,
        id: &'a Uuid,
        title: &'a str,
        body: &'a str,
        topic: Option<&'a str>,
    ) -> Exercise {
        let new_exercise = NewExercise::new(id, title, body, topic);

        diesel::insert_into(exercises::table)
            .values(&new_exercise)
            .get_result(conn)
            .expect("Error saving new exercise.")
    }
}

pub mod sqlite {
    use super::schema::exercises;
    use crate::database::models::{Exercise, NewExercise, Uuid};
    use diesel::prelude::*;

    use diesel::connection::Connection;
    pub use diesel::sqlite::SqliteConnection;

    pub fn get_exercise_by_title<'a>(conn: &SqliteConnection, title: &'a str) -> Option<Exercise> {
        exercises::table
            .filter(exercises::title.eq(title))
            .first::<Exercise>(conn)
            .ok()
    }

    pub fn create_exercise<'a>(
        conn: &SqliteConnection,
        id: &'a Uuid,
        title: &'a str,
        body: &'a str,
        topic: Option<&'a str>,
    ) -> Exercise {
        let new_exercise = NewExercise::new(id, title, body, topic);

        diesel::insert_into(exercises::table)
            .values(&new_exercise)
            .execute(conn)
            .expect("Error saving new exercise.");

        exercises::table
            .filter(exercises::id.eq(new_exercise.id))
            .first::<Exercise>(conn)
            .expect("Error retrieving new exercise.")
    }

    pub fn new_in_memory() -> SqliteConnection {
        let conn = SqliteConnection::establish(":memory:")
            .expect("Failed to connect to in-memory sqlite database.");

        let query =
            std::fs::read_to_string("./migrations/2019-06-02-153217_create_exercises/up.sql")
                .expect("Failed to read SQL schema.");

        diesel::sql_query(query)
            .execute(&conn)
            .expect("Failed to create table 'exercises'.");
        conn
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::database::models::{Exercise, Uuid};
    use sqlite::SqliteConnection;

    const ALBATROSS_BODY: &'static str = "Albatrosses, of the biological family Diomedeidae, are
        large seabirds related to the procellariids, storm petrels, and diving petrels in the order
        Procellariiformes (the tubenoses).";

    fn setup_common() -> (SqliteConnection, Exercise) {
        let conn = sqlite::new_in_memory();

        let exercise =
            sqlite::create_exercise(&conn, &Uuid::new(), "Albatross", ALBATROSS_BODY, None);
        (conn, exercise)
    }

    fn teardown_common() {}

    fn run_test_common<F: Fn(SqliteConnection, Exercise) -> ()>(f: F) {
        let (conn, e) = setup_common();
        f(conn, e);
        teardown_common();
    }

    #[test]
    fn it_works() {
        run_test_common(|conn, e| {
            let e2 = sqlite::get_exercise_by_title(&conn, "Albatross")
                .expect("Test exercise not found.");
            assert_eq!(e, e2);
        });
    }
}
